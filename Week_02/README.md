# 学习笔记
### 本周是算法训练营第11期的第二周，总体感受是
	①课程视频接受难度中等，个别视频片段需要重复多次才能够理解；
	②日常刷题水平没有长进，仍然处于多数需要直接看答案的阶段；
	③本周学习总体感受是对于算法题解，越来越觉得能够理解解题思路即可，还是以背题为主，尤其是本周增加了新的多维度数据结构和迭代算法后，
    更加需要通过看别人的解题思路和背诵答案，来增加自己的基本功。可能在后续的学习过程中，通过逐渐理解更多的解题思路，同时通过条件反射的代码编写，能够从量变转化为质变。

## 哈希表（HashMap）
	查询复杂度：O(1)
	插入复杂度：O(1)
	删除复杂度：O(1)
	空间复杂度：O(n)
	一种通过哈希算法将值与键进行映射的键值对表结构（值可能是多种对象类型，产生哈希碰撞时可能是链表或者树），其具有较高的查询、插入和删除性能，哈希算法的好坏直接影响哈希碰撞的概率，进而影响到数据结构的复杂度和操作性能。一般当期长度占用到75%时，系统会重新创建一个长度为当前长度二倍的哈希表，同时将原来的哈希表内容copy过来。

## 映射（Map）
    以HashMap实现为例
	查询复杂度：O(1)
	插入复杂度：O(1)
	删除复杂度：O(1)
	空间复杂度：O(n)
	一种键值（Key-Value）对数据结构,在Java中以接口形式存在，其键是不重复的，值可以重复。现在了解的算法问题中，一般用map记录不同内容的重复次数问题。重点学习java中hashMap的putVal和getNode方法的实现。

## 集合（Set）
    以HashSet实现为例
	查询复杂度：O(1)
	插入复杂度：O(1)
	删除复杂度：O(1)
	空间复杂度：O(n)
	一种由不重复键组成的数据集合，其在java中是以接口形式存在，其具体实现有很多种，例如EnumSet、HashSet、ConcurrentSkipListSet、TreeSet、LinkedHashSet等。在算法中主要用其解决值在集合中是否存在的问题。

## 树
	查询复杂度：O(n)
	插入复杂度：O(n)
	删除复杂度：O(n)
	空间复杂度：O(n)
	一种二维数据结构，其结构包括父节点（Parent Node）和子节点（Child Node），其实现一般以递归方式实现。

## 二叉树
	查询复杂度：O(n)
	插入复杂度：O(n)
	删除复杂度：O(n)
	空间复杂度：O(n)
	每父节点只有2个子节点的树形结构，其子节点一般称为left node和right node，当二叉树是无序的情况下，其各类操作复杂度都是O(n),没有明显优势。

## 二叉搜索树
	查询复杂度：O(logn)
	插入复杂度：O(logn)
	删除复杂度：O(logn)
	空间复杂度：O(n)
	有序的二叉树结构，由于其有序的特点，使得其各类操作复杂度都降低为O(logn),具有较好的性能。

## 堆
	查询复杂度：O(1)
	插入复杂度：O(1)或O(logn)
	删除复杂度：O(logn)
	空间复杂度：O(n)
	一种能够快速找到一组数中最大值或最小值的数据结构

# 二叉堆
	查询复杂度：O(1)
	插入复杂度：O(logn)
	删除复杂度：O(logn)
	空间复杂度：O(n)
	是一个完全二叉树，（以大顶堆为例）并且其任意节点的值都大于等于其子节点的值。由于以上两个的特点，使得其能够通过O(1)的时间复杂度找到其最大值或者最小值。二叉堆一般通过数组来实现，索引为i的左子节点的索引为（2i+1），右子节点的索引为2i+2，索引为i的父节点为floor（（i-1）/2）。

# 图
	查询复杂度：根据具体实现不同
	插入复杂度：根据具体实现不同
	删除复杂度：根据具体实现不同
	空间复杂度：O(n)
	一种表示点和边关系的二维数据结构，可以由邻接表或者邻接矩阵表示。其与树的区别是图是存在环状链表的结构。

